/*******************************************************************************
 * Copyright (c) 2004, 2016 IBM Corporation and others.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
package org.eclipse.core.commands;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

/**
 * <p>
 * A central repository for commands -- both in the defined and undefined
 * states. Commands can be created and retrieved using this manager. It is
 * possible to listen to changes in the collection of commands by attaching a
 * listener to the manager.
 * </p>
 *
 * @see CommandManager#getCommand(String)
 * @since 3.1
 */
public final class CommandManager {

	/**
	 * The identifier of the category in which all auto-generated commands will
	 * appear. This value must never be <code>null</code>.
	 *
	 * @since 3.2
	 */
	public static final String AUTOGENERATED_CATEGORY_ID = "org.eclipse.core.commands.categories.autogenerated"; //$NON-NLS-1$

	/**
	 * The escape character to use for serialization and deserialization of
	 * parameterized commands.
	 */
	static final char ESCAPE_CHAR = '%';

	/**
	 * The character that separates a parameter id from its value.
	 */
	static final char ID_VALUE_CHAR = '=';

	/**
	 * The character that indicates the end of a list of parameters.
	 */
	static final char PARAMETER_END_CHAR = ')';

	/**
	 * The character that separators parameters from each other.
	 */
	static final char PARAMETER_SEPARATOR_CHAR = ',';

	/**
	 * The character that indicates the start of a list of parameters.
	 */
	static final char PARAMETER_START_CHAR = '(';

	/**
	 * Unescapes special characters in the command id, parameter ids and
	 * parameter values for {@link #deserialize(String)}. The special characters
	 * {@link #PARAMETER_START_CHAR}, {@link #PARAMETER_END_CHAR},
	 * {@link #ID_VALUE_CHAR}, {@link #PARAMETER_SEPARATOR_CHAR} and
	 * {@link #ESCAPE_CHAR} are escaped by prepending an {@link #ESCAPE_CHAR}
	 * character.
	 * <p>
	 * See also ParameterizedCommand.escape(String)
	 * </p>
	 *
	 * @param escapedText
	 *            a <code>String</code> that may contain escaped special
	 *            characters for command serialization.
	 * @return a <code>String</code> representing <code>escapedText</code>
	 *         with any escaped characters replaced by their literal values
	 * @throws Exception 
	 * @throws SerializationException
	 *             if <code>escapedText</code> contains an invalid escape
	 *             sequence
	 * @since 3.2
	 */
	private static String unescape(final String escapedText) throws Exception {

		// defer initialization of a StringBuilder until we know we need one
		StringBuilder buffer = null;

		for (int i = 0; i < escapedText.length(); i++) {

			char c = escapedText.charAt(i);
			if (c != ESCAPE_CHAR) {
				// normal unescaped character
				if (buffer != null) {
					buffer.append(c);
				}
			} else {
				if (buffer == null) {
					buffer = new StringBuilder(escapedText.substring(0, i));
				}

				if (++i < escapedText.length()) {
					c = escapedText.charAt(i);
					switch (c) {
					case PARAMETER_START_CHAR:
					case PARAMETER_END_CHAR:
					case ID_VALUE_CHAR:
					case PARAMETER_SEPARATOR_CHAR:
					case ESCAPE_CHAR:
						buffer.append(c);
						break;
					default:
						throw new Exception(
								"Invalid character '" + c + "' in escape sequence"); //$NON-NLS-1$ //$NON-NLS-2$
					}
				} else {
					throw new Exception(
							"Unexpected termination of escape sequence"); //$NON-NLS-1$
				}
			}

		}

		if (buffer == null) {
			return escapedText;
		}

		return buffer.toString();
	}

	/**
	 * The map of category identifiers (<code>String</code>) to categories (
	 * <code>Category</code>). This collection may be empty, but it is never
	 * <code>null</code>.
	 */
	private final Map<String, Category> categoriesById = new HashMap<>();

	/**
	 * The set of identifiers for those categories that are defined. This value
	 * may be empty, but it is never <code>null</code>.
	 */
	private final Set<String> definedCategoryIds = new HashSet<>();

	/**
	 * The set of identifiers for those command parameter types that are
	 * defined. This value may be empty, but it is never <code>null</code>.
	 *
	 * @since 3.2
	 */
	private final Set<String> definedParameterTypeIds = new HashSet<>();

	private boolean shouldCommandFireEvents = true;

	/**
	 * Sets the name and description of the category for uncategorized commands.
	 * This is the category that will be returned if
	 * {@link #getCategory(String)} is called with <code>null</code>.
	 *
	 * @param name
	 *            The name of the category for uncategorized commands; must not
	 *            be <code>null</code>.
	 * @param description
	 *            The description of the category for uncategorized commands;
	 *            may be <code>null</code>.
	 * @since 3.2
	 */
	public void defineUncategorizedCategory(final String name,
			final String description) {
		final Category category = getCategory(AUTOGENERATED_CATEGORY_ID);
		category.define(name, description);
	}

	/**
	 * Gets the category with the given identifier. If no such category
	 * currently exists, then the category will be created (but be undefined).
	 *
	 * @param categoryId
	 *            The identifier to find; must not be <code>null</code>. If
	 *            the category is <code>null</code>, then a category suitable
	 *            for uncategorized items is defined and returned.
	 * @return The category with the given identifier; this value will never be
	 *         <code>null</code>, but it might be undefined.
	 * @see Category
	 */
	public Category getCategory(final String categoryId) {
		if (categoryId == null) {
			return getCategory(AUTOGENERATED_CATEGORY_ID);
		}

		Category category = categoriesById.get(categoryId);
		if (category == null) {
			category = new Category(categoryId);
			categoriesById.put(categoryId, category);
		}

		return category;
	}

	/**
	 * Returns the categories that are defined.
	 *
	 * @return The defined categories; this value may be empty, but it is never
	 *         <code>null</code>.
	 * @since 3.2
	 */
	public Category[] getDefinedCategories() {
		final Category[] categories = new Category[definedCategoryIds.size()];
		final Iterator<String> categoryIdItr = definedCategoryIds.iterator();
		int i = 0;
		while (categoryIdItr.hasNext()) {
			String categoryId = categoryIdItr.next();
			categories[i++] = getCategory(categoryId);
		}
		return categories;
	}

	/**
	 * Returns the set of identifiers for those category that are defined.
	 *
	 * @return The set of defined category identifiers; this value may be empty,
	 *         but it is never <code>null</code>.
	 */
	@SuppressWarnings("rawtypes")
	public Set getDefinedCategoryIds() {
		return Collections.unmodifiableSet(definedCategoryIds);
	}

	/**
	 * Returns the set of identifiers for those parameter types that are
	 * defined.
	 *
	 * @return The set of defined command parameter type identifiers; this value
	 *         may be empty, but it is never <code>null</code>.
	 * @since 3.2
	 */
	@SuppressWarnings("rawtypes")
	public Set getDefinedParameterTypeIds() {
		return Collections.unmodifiableSet(definedParameterTypeIds);
	}


	/**
	 * Searches for the index of a <code>char</code> in a <code>String</code>
	 * but disregards characters prefixed with the {@link #ESCAPE_CHAR} escape
	 * character. This is used by {@link #deserialize(String)} and
	 * {@link #getParameterizations(String, IParameter[])} to parse the
	 * serialized parameterized command string.
	 *
	 * @param escapedText
	 *            the string to search for the index of <code>ch</code> in
	 * @param ch
	 *            a character to search for in <code>escapedText</code>
	 * @return the index of the first unescaped occurrence of the character in
	 *         <code>escapedText</code>, or <code>-1</code> if the
	 *         character does not occur unescaped.
	 * @see String#indexOf(int)
	 */
	private int unescapedIndexOf(final String escapedText, final char ch) {

		int pos = escapedText.indexOf(ch);

		// first char can't be escaped
		if (pos == 0) {
			return pos;
		}

		while (pos != -1) {
			// look back for the escape character
			if (escapedText.charAt(pos - 1) != ESCAPE_CHAR) {
				return pos;
			}

			// scan for the next instance of ch
			pos = escapedText.indexOf(ch, pos + 1);
		}

		return pos;

	}

}
